//! OIDC Integration Tests
//!
//! These tests validate the OIDC authentication implementation with mock tokens
//! and verify JWT signature verification, JWKS fetching, and caching.

use base64::engine::general_purpose::URL_SAFE_NO_PAD;
use base64::Engine;
use jsonwebtoken::{encode, Algorithm, EncodingKey, Header};
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::collections::HashMap;

/// Mock RSA keypair for testing (2048-bit PKCS#8 format)
/// In production, this would be generated by the OIDC provider
const MOCK_RSA_PRIVATE_KEY: &str = r#"-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDYwMAGyC0XRIt2
YE74aX6CEYjRWnccjPTXunqOVslGBS73HMl5rNto15h0aLmiRGfujrwAvyahNB9X
enFSrS4E8UhTN9rKNKfIkphkSlEusAtBiaKjcibcxPlftmV6B+0GvTQH4F/b/kOU
pLKSkLfogpUw4mrF29RhQGOclsNr8UdEjiNu4mHZMu8SS0k7oB4qy9xWBRZInHPw
5DckBJK0f04qLveV5ALZsMXDd9ELeJ6TZGM/jst+kVzzyXFtdKfXmBSANOJpjXfc
OFMjR08fMdMssHovKX9rUS8vgkiHJdljvqJfVaYuHvb3nsqjGvUuiCIQXXza5c6O
uWTHc/t1AgMBAAECggEAFPMSTEWCOC6/lP4re86Ec/FaajOmcgu8qXIkYMgKFZqw
JqGxZnF61mgKG+w4TvLyIahJiv/uraOCSPv0YoOLAF7KuQJbwvHyaowirwTQ0mSg
/eFd5xLEJ0/hc2sHZVNJST61vfIlibeKVB5UBR74K4Cdh1dG7x83aHvm9M5Mjoza
nfGK+SwdeJ7s+dP9FwfCvynzf6uAJiaCTw4h52XaNjcjCi9VyXuKKVUceWArQlMm
c4/Pe8NtKmIIPdtMZt4LDAZOdPZJdmMPL33ewSwjoq4tcIDc0EIFLq6a/Ih9MrW9
rWWGcPXA49CHC7BgW1Q3HZ/T1rNiHmQdzV/IHFQMUQKBgQD1bet9E0PECnnIlk63
6HT8CUB/lv3i2ctiM+JJdYWUdychHD7gbXcPe023v/fk7lJPIB2Q50DfYuDGwL4m
Nymyg1TqYigBdOplNYEP8ty1OWRce0SM1J7AvEwbsvJRrhroU3nVDmJsJTZaSQoH
CVMSzFozMiQ6vHu7BYQTDVae5QKBgQDiFqWFzgqj9heBfTXo+X5BllODEzu1I62t
ZRYtmNfm8pewMumnzRq1wsmYjrlq6B5TyU9eHjDjCFVA4JXbYvladygeDX2MnLZ9
S3dYkSoi9ogtUnGaUNbErVnmnChubal5j3J84/ub22eKqHtHymCOEuMYgTL4jVMK
vGadxhyRUQKBgQCH/ve9X95uFAv1nWxTNgkU25+U07stZ9fuO6fJYsi5Quk4zKj+
vUl7F60yA7q+bVzIoZgggjQNVIIPQCBdlrWRSHrWQbu/SuTTXjl89+tatEmrgVaz
3uF1FSHrO1ZQ8nPQhuj8qTLakCg1EUHwMjeJNBlLQx6WOXkqYd0UnZCBDQKBgQCf
OYnLCUfPH0KArHjqIcO8Vy1rc4EqWf03z6hl5m2vNYyEx+ZsifNUrOEjcui8lMq/
AVjHFQYi7jx0W3bOsg6gmqiDOccA32FaLmrX0ixVwUA4gwaEwofurZNR6QpEczDW
7qKXuEv8APIT4gIoliuYA08yc9M83vLr7bFrThnScQKBgFJgQVZrE59WmmdO9JbQ
XBAgPBrkTsgy8soKXOrcoRgnhlxx03Fep3CbbT8fAE6mgB0xAM19Lu3tCWgtnnMl
CDf+S+ChC9pNQ2nlT6aabszy91wGeVK7JTWJ62bLFvxHJJ+W9yV9uy1icpmfzwqx
HWL/2YK0mCHCukorzQ6mNUrD
-----END PRIVATE KEY-----"#;

/// Mock OIDC configuration for testing
const MOCK_ISSUER: &str = "https://mock-oidc-provider.example.com";
const MOCK_CLIENT_ID: &str = "horcrux-test-client";

/// Generate RSA key components (n, e) from the test key
/// In a real scenario, these would come from the OIDC provider's JWKS endpoint
fn get_mock_rsa_components() -> (String, String) {
    // These are the base64url-encoded n and e from the test private key above
    // In production, fetch these from /.well-known/jwks.json
    let n = "2MDABsgtF0SLdmBO-Gl-ghGI0Vp3HIz017p6jlbJRgUu9xzJeazbaNeYdGi5okRn7o68AL8moTQfV3pxUq0uBPFIUzfayjSnyJKYZEpRLrALQYmio3Im3MT5X7ZlegftBr00B-Bf2_5DlKSykpC36IKVMOJqxdvUYUBjnJbDa_FHRI4jbuJh2TLvEktJO6AeKsvcVgUWSJxz8OQ3JASStH9OKi73leQC2bDFw3fRC3iek2RjP47LfpFc88lxbXSn15gUgDTiaY133DhTI0dPHzHTLLB6Lyl_a1EvL4JIhyXZY76iX1WmLh72957Koxr1LogiEF182uXOjrlkx3P7dQ";
    let e = "AQAB";  // 65537 in base64url

    (n.to_string(), e.to_string())
}

/// Mock ID token claims for testing
#[derive(Debug, Serialize, Deserialize)]
struct MockIdTokenClaims {
    iss: String,
    sub: String,
    aud: String,
    exp: u64,
    iat: u64,
    nonce: Option<String>,
    email: Option<String>,
    name: Option<String>,
}

/// Generate a mock JWT ID token signed with the test RSA key
fn generate_mock_id_token(sub: &str, nonce: Option<&str>) -> Result<String, Box<dyn std::error::Error>> {
    let now = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)?
        .as_secs();

    let claims = MockIdTokenClaims {
        iss: MOCK_ISSUER.to_string(),
        sub: sub.to_string(),
        aud: MOCK_CLIENT_ID.to_string(),
        exp: now + 3600, // 1 hour from now
        iat: now,
        nonce: nonce.map(|s| s.to_string()),
        email: Some(format!("{}@example.com", sub)),
        name: Some(format!("Test User {}", sub)),
    };

    let mut header = Header::new(Algorithm::RS256);
    header.kid = Some("test-key-1".to_string());

    let encoding_key = EncodingKey::from_rsa_pem(MOCK_RSA_PRIVATE_KEY.as_bytes())?;
    let token = encode(&header, &claims, &encoding_key)?;

    Ok(token)
}

/// Generate a mock JWKS (JSON Web Key Set) response
fn generate_mock_jwks() -> serde_json::Value {
    let (n, e) = get_mock_rsa_components();

    json!({
        "keys": [
            {
                "kty": "RSA",
                "kid": "test-key-1",
                "use": "sig",
                "alg": "RS256",
                "n": n,
                "e": e
            }
        ]
    })
}

/// Generate an invalid token (wrong signature)
fn generate_invalid_token() -> String {
    // Create a token with valid structure but invalid signature
    let header = URL_SAFE_NO_PAD.encode(r#"{"alg":"RS256","typ":"JWT","kid":"test-key-1"}"#);
    let payload = URL_SAFE_NO_PAD.encode(r#"{"iss":"https://evil.com","sub":"hacker","aud":"horcrux-test-client"}"#);
    let fake_signature = URL_SAFE_NO_PAD.encode(b"invalid_signature_data_here");

    format!("{}.{}.{}", header, payload, fake_signature)
}

/// Generate an expired token
fn generate_expired_token(sub: &str) -> Result<String, Box<dyn std::error::Error>> {
    let now = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)?
        .as_secs();

    let claims = MockIdTokenClaims {
        iss: MOCK_ISSUER.to_string(),
        sub: sub.to_string(),
        aud: MOCK_CLIENT_ID.to_string(),
        exp: now - 3600, // 1 hour ago (expired!)
        iat: now - 7200, // 2 hours ago
        nonce: None,
        email: Some(format!("{}@example.com", sub)),
        name: Some(format!("Test User {}", sub)),
    };

    let mut header = Header::new(Algorithm::RS256);
    header.kid = Some("test-key-1".to_string());

    let encoding_key = EncodingKey::from_rsa_pem(MOCK_RSA_PRIVATE_KEY.as_bytes())?;
    let token = encode(&header, &claims, &encoding_key)?;

    Ok(token)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_mock_id_token() {
        let token = generate_mock_id_token("testuser", Some("test-nonce-123"))
            .expect("Failed to generate mock token");

        assert!(!token.is_empty());
        assert_eq!(token.matches('.').count(), 2, "JWT should have 3 parts separated by dots");

        // Verify token starts with valid base64url characters
        let parts: Vec<&str> = token.split('.').collect();
        assert_eq!(parts.len(), 3);
    }

    #[test]
    fn test_generate_mock_jwks() {
        let jwks = generate_mock_jwks();

        assert!(jwks.get("keys").is_some());
        let keys = jwks["keys"].as_array().unwrap();
        assert_eq!(keys.len(), 1);

        let key = &keys[0];
        assert_eq!(key["kty"], "RSA");
        assert_eq!(key["kid"], "test-key-1");
        assert_eq!(key["alg"], "RS256");
        assert!(key["n"].is_string());
        assert!(key["e"].is_string());
    }

    #[test]
    fn test_token_structure() {
        let token = generate_mock_id_token("user123", None)
            .expect("Failed to generate token");

        let parts: Vec<&str> = token.split('.').collect();

        // Decode header
        let header_json = URL_SAFE_NO_PAD.decode(parts[0]).expect("Failed to decode header");
        let header: serde_json::Value = serde_json::from_slice(&header_json)
            .expect("Failed to parse header");

        assert_eq!(header["alg"], "RS256");
        assert_eq!(header["kid"], "test-key-1");

        // Decode payload
        let payload_json = URL_SAFE_NO_PAD.decode(parts[1]).expect("Failed to decode payload");
        let payload: MockIdTokenClaims = serde_json::from_slice(&payload_json)
            .expect("Failed to parse payload");

        assert_eq!(payload.iss, MOCK_ISSUER);
        assert_eq!(payload.sub, "user123");
        assert_eq!(payload.aud, MOCK_CLIENT_ID);
    }

    #[test]
    fn test_expired_token_generation() {
        let token = generate_expired_token("testuser")
            .expect("Failed to generate expired token");

        let parts: Vec<&str> = token.split('.').collect();
        let payload_json = URL_SAFE_NO_PAD.decode(parts[1]).expect("Failed to decode payload");
        let payload: MockIdTokenClaims = serde_json::from_slice(&payload_json)
            .expect("Failed to parse payload");

        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs();

        // Verify token is actually expired
        assert!(payload.exp < now, "Token should be expired");
    }

    #[test]
    fn test_nonce_in_token() {
        let nonce = "unique-nonce-12345";
        let token = generate_mock_id_token("user", Some(nonce))
            .expect("Failed to generate token");

        let parts: Vec<&str> = token.split('.').collect();
        let payload_json = URL_SAFE_NO_PAD.decode(parts[1]).expect("Failed to decode payload");
        let payload: MockIdTokenClaims = serde_json::from_slice(&payload_json)
            .expect("Failed to parse payload");

        assert_eq!(payload.nonce, Some(nonce.to_string()));
    }

    #[test]
    fn test_invalid_token_structure() {
        let invalid = generate_invalid_token();

        // Token should have 3 parts
        assert_eq!(invalid.matches('.').count(), 2);

        // But signature should be invalid (this would be verified by the OIDC provider)
        let parts: Vec<&str> = invalid.split('.').collect();
        let signature = parts[2];

        // The signature should decode but won't match RSA verification
        assert!(URL_SAFE_NO_PAD.decode(signature).is_ok());
    }
}

/// Integration tests requiring OIDC provider simulation
/// These tests would connect to a mock HTTP server in a full integration test
#[cfg(test)]
mod integration_tests {
    use super::*;

    /// Test case: Verify that we can generate and decode a valid token
    #[test]
    fn test_token_roundtrip() {
        // Generate token
        let token = generate_mock_id_token("alice", Some("nonce-123"))
            .expect("Failed to generate token");

        // In a real test, we would:
        // 1. Start mock OIDC provider HTTP server
        // 2. Configure OidcProvider to use mock server
        // 3. Call verify_id_token() and verify it succeeds
        // 4. Verify claims match expected values

        // For now, verify token structure
        assert!(!token.is_empty());
        assert!(token.contains('.'));
    }

    /// Test case: Verify JWKS structure is correct
    #[test]
    fn test_jwks_structure_for_verification() {
        let jwks = generate_mock_jwks();
        let (n, e) = get_mock_rsa_components();

        // Verify JWKS contains necessary fields for verification
        assert!(jwks["keys"][0]["kty"].as_str().unwrap() == "RSA");
        assert!(jwks["keys"][0]["n"].as_str().unwrap() == n);
        assert!(jwks["keys"][0]["e"].as_str().unwrap() == e);
        assert!(jwks["keys"][0]["kid"].as_str().unwrap() == "test-key-1");
    }

    /// Test multiple tokens with same key
    #[test]
    fn test_multiple_tokens_same_key() {
        let token1 = generate_mock_id_token("user1", Some("nonce1"))
            .expect("Failed to generate token1");
        let token2 = generate_mock_id_token("user2", Some("nonce2"))
            .expect("Failed to generate token2");

        // Both should be valid tokens
        assert_ne!(token1, token2);

        // Both should have the same kid in header
        let parts1: Vec<&str> = token1.split('.').collect();
        let parts2: Vec<&str> = token2.split('.').collect();

        let header1_json = URL_SAFE_NO_PAD.decode(parts1[0]).unwrap();
        let header2_json = URL_SAFE_NO_PAD.decode(parts2[0]).unwrap();

        let header1: serde_json::Value = serde_json::from_slice(&header1_json).unwrap();
        let header2: serde_json::Value = serde_json::from_slice(&header2_json).unwrap();

        assert_eq!(header1["kid"], header2["kid"]);
    }
}

/// Documentation and usage examples
#[cfg(test)]
mod examples {
    use super::*;

    /// Example: How to use mock tokens in tests
    #[test]
    fn example_generate_token_for_test() {
        // Generate a valid token for user "bob" with nonce
        let token = generate_mock_id_token("bob", Some("test-nonce"))
            .expect("Token generation failed");

        println!("Generated mock ID token:");
        println!("{}", token);

        // This token can be used to test OIDC verification
        assert!(!token.is_empty());
    }

    /// Example: Generate JWKS for mock server
    #[test]
    fn example_generate_jwks_response() {
        let jwks = generate_mock_jwks();

        println!("Mock JWKS response:");
        println!("{}", serde_json::to_string_pretty(&jwks).unwrap());

        // This JWKS can be served from /.well-known/jwks.json in tests
    }

    /// Example: Test token validation scenarios
    #[test]
    fn example_validation_scenarios() {
        // Valid token
        let valid_token = generate_mock_id_token("user", Some("nonce"))
            .expect("Failed to generate valid token");
        println!("Valid token: {}", valid_token);

        // Expired token
        let expired_token = generate_expired_token("user")
            .expect("Failed to generate expired token");
        println!("Expired token: {}", expired_token);

        // Invalid token
        let invalid_token = generate_invalid_token();
        println!("Invalid token: {}", invalid_token);
    }
}
